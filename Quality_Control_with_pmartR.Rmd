---
title: "Quality Control and Normalization of Peptide Data with the `pmartR` Package"
author: "Kelly Stratton, Rachel Richardson, Lisa Bramer"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
  rmarkdown::html_vignette:
    fig_caption: yes
    self_contained: yes
bibliography: bibliography.bib
vignette: |
  %\VignetteIndexEntry{Analyzing Peptide Data with the pmartR Package} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(warning=FALSE, fig.width = 8, fig.height = 6)

```

```{r logo, out.width = "100px", echo=FALSE}
knitr::include_graphics("pmartR_logo_final.jpg")

library(pmartR)
library(pmartRdata)
library(ggplot2)
library(reshape2)
library(pander)

```

This vignette describes the pmartR package functionality for quality control (QC) processing of mass spectrometry (MS) pan-omics data, in particular proteomics data at the peptide level. This includes data transformation, specification of groups that are to be compared against each other, filtering of features and/or samples, data normalization, and data summarization (correlation, principal components analysis). It is based on example data in the pmartRdata package. 

Additional datasets available in the pmartRdata package include the following data types: protein level data, lipidomic data, and metabolomic data. A separate vignette describes the statistical analysis capabilities of pmartR.

## 1. Creating a data object (omicsData) in pmartR

The pmartR package relies on the creation of a standardized data object that is used for data manipulation. This data object requires specific formatting of input data and selection of data type to ensure that analyses are computed correctly. These data objects will be referred to overall as **omicsData** herein, where specific classes of omicsData will be referred to more specifically.



### 1a. Input data format

Below we load in 3 data.frames from the pmartRdata package. In this example,  **$p$ is the number of unique peptides observed** and **$n$ is the number of samples**, respectively `r nrow(pep_edata)` peptides and `r nrow(pep_fdata)` samples.

- `pep_edata`: A $p * (n + 1)$ data.frame of expression data, where each row corresponds to data for each peptide and each column corresponds to a unique sample identifier. An additional peptide identifier/name column should also be present anywhere in the data.frame.

    The example denotes the unique peptide identifier/name column by 'Mass_Tag_ID' and all other column names are unique sample identifiers.

- `pep_fdata`: A data.frame with $n$ rows. Each row corresponds to a sample with one column giving the unique sample identifiers found in e_data column names and other columns providing qualitative and/or quantitative traits of each sample (e.g. experimental group, sample metadata, patient demographics). 

    The example contains the sample identifier as "SampleID" and 'Condition' indicates the experimental group for each sample, either 'Infection' (samples that were infected with some pathogen) or 'Mock' (uninfected samples used as a control).

- `pep_emeta`: An optional data.frame with at least $p$ rows and a column with column name and entries identical to the unique identifier column in `e_data`. Each row corresponds to a peptide with one column giving peptide names and other columns giving meta information (e.g. mappings of peptides to proteins, class of molecule, pathways). 

    The example pairs the peptide identifiers ('Mass_Tag_ID', corresponding with the same column in edata) with the protein identification name to which each mass tag ID maps ('Protein'), a reference identifier ('Ref_ID'), and the peptide sequence ('Peptide_Sequence'). Note that the mass tag IDs are unique ($n_{peptide} =$ `r length(unique(pep_emeta$Mass_Tag_ID))`) while the protein identifiers are not ($n_{protein} =$ `r length(unique(pep_emeta$Protein))`) since multiple peptides often map to the same protein.

<br>

**pep_edata**

```{r edata1, echo = TRUE, eval=FALSE}
data("pep_edata")    ## Load data.frame from pmartRdata
dim(pep_edata)       ## Print dimensions of the data.frame (rows, columns)
pep_edata[1:6,1:5]   ## Visualize the first 6 rows and first 5 columns of data
```

```{r edata2, echo = FALSE}
data("pep_edata")    ## Load data.frame from pmartRdata
dim(pep_edata)       ## Print dimensions of the data.frame (rows, columns)
row.names(pep_edata) <- NULL
pander(pep_edata[1:6,1:5])   ## Visualize the first 6 rows and first 5 columns of data

```

**pep_fdata**

```{r fdata1, echo = TRUE, eval=FALSE}
data("pep_fdata")    ## Load data.frame from pmartRdata
dim(pep_fdata)       ## Print dimensions of the data.frame (rows, columns)
head(pep_fdata)      ## Visualize the first 6 rows of data
```

```{r fdata2, echo = FALSE}
data("pep_fdata")    ## Load data.frame from pmartRdata
dim(pep_fdata)       ## Print dimensions of the data.frame (rows, columns)
row.names(pep_fdata) <- NULL
pander(head(pep_fdata))      ## Visualize the first 6 rows of data
```

**pep_emeta**

```{r emeta1, echo = TRUE, eval=FALSE}
data("pep_emeta")    ## Load data.frame from pmartRdata
dim(pep_emeta)       ## Print dimensions of the data.frame (rows, columns)
head(pep_emeta)      ## Visualize the first 6 rows of data
```

```{r emeta2, echo = FALSE}
data("pep_emeta")    ## Load data.frame from pmartRdata
dim(pep_emeta)       ## Print dimensions of the data.frame (rows, columns)
row.names(pep_emeta) <- NULL
pander(head(pep_emeta))      ## Visualize the first 6 rows of data
```

<br>

### 1b. Selection of omicsData class

Several different classes of omicData are available in pmartR depending on if the user is conducting proteomic, lipidomic, or metabolomic analysis. They are classified as follows:

Proteomics (Peptides) - `as.pepData()`, `as.isobaricpepData()`

Proteomics (Proteins) - `as.proData`

Lipidomics - `as.lipidData`

Metabolomics - `as.metabData()`

Each of these data types have example data also included in the pmartRdata package in analogous formats to the peptide data described above. Different classes permit other class specific functions available in pmartR, including quantification of peptide-protein mappings using `proteomic_filter()`, normalizing proteomic data with `spans_procedure`, and quantifying proteoforms with `bpquant()`. For our example, `as.pepData()` is the appropriate choice and we will demonstrate each of these functions.

-----

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Feature note:** Sample names beginning with numbers or containing dashes are modified in R when processed by read.csv() or data.frame() functions. This modification replaces dashes with periods and pastes an "X" before column names, throwing an error in when using the above functions since column names of e_data are not identical to f_data sample identifiers. Passing the argument `check.names = FALSE` will circumvent this issue; an example below demonstrates this instance using metabolomic data.

</div>

<br>

```{r checknamesFALSE}
edata <- read.csv(system.file("extdata", 
                              "metab_edata_sample_names.csv", 
                              package="pmartRdata"), 
                  header=TRUE)

edata2 <- read.csv(system.file("extdata", 
                              "metab_edata_sample_names.csv", 
                              package="pmartRdata"), 
                   header=TRUE, check.names=FALSE)

fdata <- read.csv(system.file("extdata", 
                              "metab_fdata_sample_names.csv", 
                              package="pmartRdata"), 
                  header=TRUE)

all(names(edata)[-1] == fdata$SampleID) ## Do the sample names match each other?
all(names(edata2)[-1] == fdata$SampleID) ## Do the sample names match each other?

```

------


### 1c. Generate pepData

The pepData object contains the 3 components loaded above. During object creation, we specify the names of the identifier columns in the `e_data`, `f_data`, and `e_meta` components of the data, as well as the scale of the data (`edata_cname = "Mass_Tag_ID", emeta_cname = "Protein", fdata_cname = "SampleID", data_scale = "abundance"`, respectively). 

<br>

We can use the `summary` function to get basic summary information for our pepData object.

```{r pepdata1, echo=TRUE, eval=FALSE}
mypepData <- as.pepData(e_data = pep_edata, 
                        edata_cname = "Mass_Tag_ID", ## Unique biomolecule identifier
                        f_data = pep_fdata, 
                        fdata_cname = "SampleID",    ## Unique sample identifier
                        e_meta = pep_emeta, 
                        emeta_cname = "Protein",     ## Grouping identifier of interest
                        data_scale = "abundance")

class(mypepData)     ## pmartR class of data object
summary(mypepData)   ## pmartR summary of data object


```

```{r pepdata2, echo=FALSE}
mypepData <- as.pepData(e_data = pep_edata, 
                        edata_cname = "Mass_Tag_ID", ## Unique biomolecule identifier
                        f_data = pep_fdata, 
                        fdata_cname = "SampleID",    ## Unique sample identifier
                        e_meta = pep_emeta, 
                        emeta_cname = "Protein",     ## Grouping identifier of interest
                        data_scale = "abundance")

class(mypepData)             ## pmartR class of data object
summary(mypepData)  ## pmartR summary of data object
```

<br>

Alternatively, the pmartRdata package contains the corresponding pepData object, which can be loaded as follows:

```{r data3}
data("pep_object")  ## Load pre-rendered pmartR pepData object
class(pep_object)   ## pmartR class of data object

rm(pep_object)      ## remove data object (we use 'mypepData' herein)
```

<br><br>

We can use the `plot()` function to display box plots for each sample in the pepData object.



```{r data4}
plot(mypepData)
```

-----

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Feature note:** Long, inconvenient-for-plotting sample names can be modified using the function `custom_sampnames()`, where the identifiers can be trimmed at the user's discretion (see "VizSampNames" column in code chunk below; all three commands generate the same trimming for the first 6 rows).

</div>

<br>

```{r editfdata, echo = TRUE, eval = FALSE}
head(pmartR::custom_sampnames(mypepData, firstn = 3)$f_data)
head(pmartR::custom_sampnames(mypepData, from = 1, to = 3)$f_data)
head(pmartR::custom_sampnames(mypepData, delim = "e", components = 1)$f_data)
```

```{r editfdata2, echo=FALSE}
pander(head(pmartR::custom_sampnames(mypepData, firstn = 3)$f_data))
```


-------


## 2. Workflow overview

Once the pepData object is created, a typical QC workflow follows the figure below. 


```{r workflowFig, out.width = "450px", echo=FALSE}
knitr::include_graphics("Process Flow Graphic3.png")
```

We will walk through the steps in this QC workflow using `mypepData`. Statistics are covered in a separate vignette, 'Statistical Analysis with the pmartR Package'.

<br>

## 3. Format & preprocess

The formatting and preprocess steps of pmartR include zero-replacement, log transformation, and designating groups of interest to compare.



### 3a. Zero-replacement

Sometimes omics abundance data contains 0s when the particular biomolecule was not detected for a given sample. It is our practice to replace any 0s with NAs as opposed to imputing the missing values. We strongly prefer NAs to imputation because we cannot know whether the biomolecule is not present in the sample, simply was below the limit of detection, or was present but missing from our data at random. The function `edata_replace()` can be used to replace values in the pepData object.

```{r format1}
mypepData <- edata_replace(mypepData, x = 0, y = NA)
```

In this dataset, there were no 0s so nothing was replaced.

<br>

### 3b. Log transformation

We also highly recommend log transforming the data prior to analysis. pmartR supports log2, log10, and natural logarithm transformations. The `edata_transform()` function provides this capability. We can also use `edata_trasnform()` to transform the data back to the abundance scale if needed. Note that the scale of the data is stored and automatically updated in the `data_info$data_scale` attribute of the pepData object. Below we log10 transform the data, then return to the abundance scale, and finally settle on the log2 scale.

```{r format2}
mypepData <- edata_transform(mypepData, data_scale = "log10")
attributes(mypepData)$data_info$data_scale

mypepData <- edata_transform(mypepData, data_scale = "abundance")
attributes(mypepData)$data_info$data_scale

mypepData <- edata_transform(mypepData, data_scale = "log2")
attributes(mypepData)$data_info$data_scale

plot(mypepData, bw_theme = TRUE)
```

-----

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Feature note:** For isobaricpepData, please normalize using `normalize_isobaric()` before continuing. This function will normalize your data by a designated reference pool sample. If you have isobaric-labeled peptide data with no reference pool samples or have already accounted for reference samples, use as.pepData to read in your data.

</div>

--------


### 3c. Group designation

Finally, we are preparing this data for statistical analysis where we will compare the samples belonging to one group to the samples belonging to another, and so we must specify the group membership of the samples. We do this using the `group_designation()` function, which modifies our pepData object and returns an updated version of it. Up to two main effects and up to two covariates may be specified (using `covariates` argument), with one main effect being required at minimum. The `time_course argument` permits users to designate a column containing time points. For the example data, we only have one option - specify the main effect to be "Condition" - since we do not have any additional information about the samples. Certain functions we will use below require that groups have been designated via the `group_designation()` function.

```{r format3}
mypepData <- group_designation(mypepData, main_effects = "Condition", 
                               covariates = NULL, time_course = NULL)

```

<br>

The `group_designation()` function creates an attribute of the dataset as follows:

```{r format4}
attributes(mypepData)$group_DF

plot(mypepData, color_by = "Condition", bw_theme=TRUE)
```

-----

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Feature note:** Plotting in pmartR is automated for each omicsData object; further customization is available using the arguments `color_by` and `order_by`, allowing the user to select a single column from f_data to highlight changes or arrange sample order in the plot. Default plotting theme can also be altered by `bw_theme = TRUE`, equivalent to the effects of ggplot2 function `theme_bw()`.

</div>

--------


## 4. Filter biomolecules

It is often good practice to filter out biomolecules (peptides in this case) that do not meet certain criteria, and pmartR offers 5 different filters. These are applied as follows:

- `proteomics_filter()` - Designed for peptide data with protein mappings in emeta; plot and summary indicate the number of peptides mapping to a protein and vice versa. User can designate a minimum number of peptides mapping to a protein when applying this filter as well as the inclusion/exclusion of degenerate peptides, defined as any peptide that maps to multiple proteins.

- `molecule_filter()` - Applicable across all data types, filters out biomolecules that are observed in at least X samples, where X is an integer defined by the user.

- `cv_filter()` - Applicable across all data types, filters biomolecules based on a user-designated pooled coefficient of variation. [@ahmed1995pooling]

- `custom_filter()` - Applicable across all data types, filters biomolecules or samples based on a user-designated biomolecule names. This is best used for removing contaminants, but also also can remove botched sample results.

- `imdanova_filter()` - Applicable across all data types, filters biomolecules based on the statistical requirements of user-designated statistical tests. These tests are an analysis of variance (ANOVA) to test for differences between means of designated groups and a G-test for the independence of missing data (Running `group_designation` is required before this filter can be used). User can select either or both to apply to the omicsData object. [@webb2010combined]


Each of the filtering functions calculates metric(s) that can be used to filter out biomolecules and returns an S3 object separate from the omicsData object. Using the `summary()` function on the filter object produces a summary of the metric(s) and using the `plot()` function produces a graph. Filters that require a user-specified threshold  to filter out peptides have corresponding `summary` and `plot` methods that take optional argument(s) to specify that threshold. Once one of the 5 peptide level filter functions has been called, the results of that function can be used in conjunction with the `applyFilt()` function to actually filter out peptides based on the metric(s) and user-specified threshold(s) and create a new, filtered data object.

<br>

### 4a. Proteomics filter

The proteomics filter is applicable only to peptide level data that contains the `e_meta` component, as it counts the number of peptides that map to each protein and/or the number of proteins to which each individual peptide maps. It returns a list of two character vectors, the first, `peptides_filt`, giving degenerate peptide names. The second, `proteins_filt`, gives the names of proteins which no longer have peptides mapping to them in the dataset. This filter does not require a user-specified threshold.

```{r proteomics_filter1, fig.width=10}
myfilter <- proteomics_filter(mypepData)
summary(myfilter)
plot(myfilter, bw_theme=TRUE)

```

<br>

With the current dataset, the majority of proteins have one peptide mapping to them (graph on the left) and all peptides map to a single protein (e.g. no degenerate peptides; graph on the right). If filtering is necessary, refer to below example code for removal of degenerate peptides and requiring at least 10 peptides mapping to each protein:

```{r }
mypepData_temp <- applyFilt(filter_object = myfilter, mypepData, 
                            degen_peps = TRUE,
                            min_num_peps = 10)
summary(mypepData_temp)
rm(mypepData_temp)
```

<br>

### 4b. Molecule filter

Filters that require a user-specified threshold to filter out peptides have corresponding `summary` and `plot` methods that take optional argument(s) to specify that threshold.

The molecule filter allows the user to remove from the dataset any biomolecule not seen in at least `min_num` of the samples. The user may specify a threshold of the minimum number of times each biomolecule must be observed across all samples; the default value is 2.

```{r molecule_filter1}
myfilter <- molecule_filter(mypepData)
summary(myfilter, min_num = 3)
plot(myfilter, bw_them = TRUE)
```

<br>

Setting the threshold to 3, we would filter 3,342 peptides out of the dataset. If we'd like to make the filter less stringent, we could use a threshold of 2 and only filter 1,872 peptides. 

```{r molecule_filter3}
summary(myfilter, min_num = 2)

mypepData <- applyFilt(filter_object = myfilter, mypepData, min_num = 2)
summary(mypepData)
```

<br>

### 4c. Coefficient of variation (CV) filter

The coefficient of variation (CV) filter calculates the pooled CV values as in [@ahmed1995pooling].

The user can then specify a CV threshold, above which peptides are removed.

```{r cv_filter1}
myfilter <- cv_filter(mypepData)
summary(myfilter, cv_threshold = 150)
plot(myfilter, cv_threshold = 150, title_size = 15, bw_theme = TRUE)

mypepData <- applyFilt(filter_object = myfilter, mypepData, cv_threshold = 150)
summary(mypepData)

```

<br>

### 4d. Custom filter

Sometimes it is known a priori that certain peptides or samples should be filtered out of the dataset prior to statistical analysis. Perhaps there are known contaminant proteins, and so peptides mapping to them should be removed, or perhaps something went wrong during sample preparation for a particular sample. On the other hand, it may be preferred to specify peptides or samples to keep (removing those not explicitly specified), and this can also be accomplished. Keep in mind that both 'remove' and 'keep' arguments cannot be specified together; either 'remove' arguments only or 'keep' arguments only may be specified in a single call to custom_filter(). 

Here, we demonstrate the removal of the peptide with Mass Tag ID 1047 and sample `Infection 1` as an example.

```{r custom_filter}
myfilter <- custom_filter(mypepData, 
                          e_data_remove = 1047, e_meta_remove = NULL, 
                          f_data_remove = "Infection1")
summary(myfilter)

mypepData_temp <- applyFilt(filter_object = myfilter, mypepData)
summary(mypepData_temp)

rm(mypepData_temp)
```

<br>

We also demonstrate how to use this filter with the 'keep' option by keeping the samples `Infection 1`, `Infection 2`, `Infection 3`, `Infection 4` and `Infection 5`.

```{r custom_filter2}
myfilter2<- custom_filter(mypepData, 
                          e_data_keep = NULL, e_meta_keep = NULL, 
                          f_data_keep = c("Infection1", 
                                          "Infection2", 
                                          "Infection3", 
                                          "Infection4", 
                                          "Infection5"))
summary(myfilter2)

mypepData_temp2<- applyFilt(filter_object = myfilter2, mypepData)
summary(mypepData_temp2)

rm(mypepData_temp2)
```


-----

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Feature note:** Note that there is a `summary()` method for objects of type custom_filt, but no `plot()` method.

</div>

--------

### 4e. IMD-ANOVA filter 

The IMD-ANOVA filter removes peptides that do not have sufficient data for the statistical tests available in the pmartR package; these are ANOVA (quantitative test) and an independence of missing data (IMD) using a g-test (qualitative test) as specified in [@webb2010combined]. When using the `summary()`, `plot()`, and `applyFilt()` functions, you can specify just one filter (ANOVA or IMD) or both, depending on the tests you'd like to perform later. Using this filter speeds up the process of performing the statistical tests. 

```{r imdanova_filter1}
myfilter <- imdanova_filter(mypepData)
```

<br>

Here we consider what the filter would look like for both ANOVA and IMD.

```{r imdanova_filter2}
summary(myfilter, min_nonmiss_anova = 2, min_nonmiss_gtest = 3)
# plot(myfilter, min_nonmiss_anova = 2, min_nonmiss_gtest = 3)
```

<br>


Here we consider what the filter would look like for just ANOVA.

```{r imdanova_filter3}
summary(myfilter, min_nonmiss_anova = 2)
#plot(myfilter, min_nonmiss_anova = 2)
```

<br>


Here we consider what the filter would look like for just IMD.

```{r imdanova_filter4}
summary(myfilter, min_nonmiss_gtest = 3)
#plot(myfilter, min_nonmiss_gtest = 3)
```

<br>


Now we apply the filter for both ANOVA and IMD.

```{r}
mypepData <- applyFilt(filter_object = myfilter, 
                       mypepData, min_nonmiss_anova = 2, 
                       min_nonmiss_gtest = 3)

summary(mypepData)
```

<br>

## 5. Filter samples

Sample filtering is encouraged in pmartR where samples are determined to be outliers, as these samples can impact further data analyses. Potential outlier detection is available in pmartR using the filter function `rmd_filter()`. Other functions in pmartR, `dim_reduction()` and `cor_result()` help the user determine if potential outliers are true outliers by visualizing groupings of samples and sample correlation trends.

<br>

### 5a. Potential outlier detection metrics

To identify any samples that are potential outliers or anomalies (due to sample quality, preparation, or processing circumstances), we use a robust Mahalanobis distance (rMd) [@matzke2011improved] score based on 2-5 metrics. The possible metrics are:

- Correlation 

- Proportion of data that is missing ("Proportion_Missing")

- Median absolute deviation ("MAD")

- Skewness

- Kurtosis

<br>

### 5b. Potential outlier identification

The rMd score can be mapped to a p-value, and a p-value threshold used to identify potentially outlying samples. In general, for proteomics data we recommend using correlation, proportion missing, MAD, and skew. A plot of the rMd values for each sample is generated, and specifying a value for 'pvalue_threshold' results in a horizontal line on the plot, with samples above the line (null hypothesis that the sample is not an outlier can be rejected) slated for filtering at the given threshold.


```{r rmd1}
myfilter <- rmd_filter(mypepData, metrics = c("Correlation", 
                                              "Proportion_Missing", 
                                              "MAD", 
                                              "Skewness"))
summary(myfilter, pvalue_threshold = 0.001)
plot(myfilter, pvalue_threshold = 0.001, bw_theme=TRUE)

```

<br>


Using the output from the `summary()` function, we can explore the outliers identified to see what metrics are driving their outlier-ness. Box plots for each metric are graphed, with the specified sample marked with an 'X'.


```{r rmd2}
plot(myfilter, sampleID = "Infection5", bw_theme=TRUE)
plot(myfilter, sampleID = "Infection8", bw_theme=TRUE)
```

We can see that Infection5 has the highest MAD, low skewness, and almost the lowest correlation, but the lowest proportion missing compared to the other samples. Infection 8 has MAD close to the median MAD value, the highest skew, the lowest correlation, and the highest proportion of missing data. We can use this information to determine whether to remove either or both of these samples. Sometimes it is also useful to look at additional data summaries to inform outlier removal, such as a principal components plot or correlation heat map.

<br>

## 6. Data summary

The pmartR package contains various methods for data summarization and exploration that can be used as part of the QC process: numeric summaries and associated plots (via the `edata_summary()` function), sequential projection pursuit principal components analysis (sppPCA) for dimension reduction (via the`dim_reduction()` function), and a correlation heat map (via the `cor_result()` function) [@stacklies2007pcamethods], [@sppca]. As for missing data summarization there are also functions to collect and plot missing data information. Missing data collection and plotting functions include, `missingval_result()`, `plot_missingval()`, `missingval_scatterplot()` and `missingval_heatmap()`. 


<br>

### 6a. Numeric summaries

We can generate numeric summaries of our data by either sample or molecule. The argument `groupvar` can be used to specify if results should be split across an experimental group column. The `edata_summary()` function computes the mean, standard deviation, median, percent of observations for which a value was observed, the minimum value, and the maximum value.

The output of this function is a list of data.frames; we merge the list output here for conciseness.

```{r edata_summary}
listofsummary <- edata_summary(omicsData = mypepData, by = "sample", groupvar = NULL)

# Veiw as a single data.frame for vizualizing in rmd
dfsummary <- listofsummary[[1]]
for(i in 2:length(listofsummary)){
  dfsummary <- merge(dfsummary,listofsummary[[i]])
}
print(head(dfsummary))
```

<br>

### 6b. Probabilistic principal components analysis

Probabilistic is a principal components analysis (PCA) algorithm that can be used in the presence of missing data [@stacklies2007pcamethods], [@sppca]. We use the `dim_reduction()` function in pmartR, specifying the dataset and the number of principal components to return (default value of 2 principal components). The `summary()` and `plot()` functions operate on the results of the `dim_reduction()` function.

Note that `dim_reduction()` requires that the `group_designation()` function has been run.

```{r sppPCA}
pca_results <- dim_reduction(mypepData, k = 2)
# summary(pca_results) 
plot(pca_results, bw_theme=TRUE)
```

<br>

### 6c. Correlation heatmap

Pearson correlation between samples is calculated based on pairwise complete biomolecules. 

```{r corr}
correlation_results <- cor_result(mypepData)
summary(correlation_results)
plot(correlation_results)
```

<br>

### 6d. Missing data

Patterns of missing data can be explored using the `missingval_result()` and `plot_missingval()` functions.

```{r missingval}

results <- missingval_result(mypepData)
plot(results, type = "bySample", bw_theme=TRUE)
plot(results, type = "byMolecule", bw_theme=TRUE)

```

In addition, the `missingval_scatterplot()` and `missingval_heatmap()` functions provide more views of the missing data.

```{r missingval_plots}

missingval_scatterplot(mypepData, palette = "Set1", bw_theme=TRUE)
missingval_heatmap(mypepData)

```

<br>

## 7. Normalize data

The next step in a typical workflow is to normalize the data. Normalization can help reduce background noise while maintaining significant trends in datasets and often helps meet assumptions for statistical analysis.


<br>

### 7a. Normalization methods

Normalization approaches consist of a subset method and a normalization function [@aastrand2003contrast], [@gautier2004affy]. Available subset methods include:

- Percentage of peptides present (PPP): Subset the data to peptides present in at least $p$ percent of samples. This subset method is specified as "ppp".

- Rank invariant peptides (RIP): First subset peptides to those present in every sample (e.g. complete peptides). Next, subject each peptide to a Kruskal Wallis test on group, and those peptides *not* significant at a given p-value threshold are retained as invariant. This subset method is specified as "rip".

- PPP-RIP: Rank invariant peptides among peptides present in a given percentage of samples. This subset method is specified as "ppp_rip".

- Top "l" order statistics (LOS): The peptides with intensities in the top "l" order statistics are retained. This subset method is specified as "los".

<br>

Available normalization functions include:

- Median centering: The sample-wise median (median of all peptides in a given sample) is subtracted from each peptide in the corresponding sample. This normalization method is specified as "median".

- Mean centering: The sample-wise mean (mean of all peptides in a given sample) is subtracted from each peptide in the corresponding sample. This normalization method is specified as "mean".

- Z-score transformation: The sample-wise mean (mean of all peptides in a given sample) is subtracted from each peptide, and the result is divided by the sample-wise standard deviation (standard deviation of all peptides in a given sample) in the corresponding sample. This normalization method is specified as "zscore".

- Median absolute deviation (MAD) transformation: The sample-wise median (median of all peptides in a given sample) is subtracted from each peptide, and the result is divided by the sample-wise MAD (MAD of all peptides in a given sample) in the corresponding sample. This normalization method is specified as "mad".

There are two ways to go about normalizing data in the pmartR package. If you know the normalization approach you'd like to use, you can directly specify it in the `normalize_data()` function. Or, if you want to see how compatible different normalization approaches are with your dataset and you're using proteomics data, you can use the `spans_procedure()` function.

<br>

### 7b. Normalization function

**If we know what approach we want to use**, we can go straight to the normalization.



```{r norm2}

# Normalize using all peptides and median centering #
norm_object <- normalize_global(omicsData = mypepData, 
                                subset_fn = "all", 
                                norm_fn = "median", 
                                apply_norm = FALSE, 
                                backtransform = TRUE)
norm_data <- normalize_global(omicsData = mypepData, 
                              subset_fn = "all", 
                              norm_fn = "median", 
                              apply_norm = TRUE, 
                              backtransform = TRUE)
plot(norm_data, 
     title_plot="Normalized Data: Median Centering Using all Peptides", 
     title_size=12,
     bw_theme = TRUE)

# Normalize using RIP 0.2 and median centering #
norm_object <- normalize_global(omicsData = mypepData, 
                                subset_fn = "rip", 
                                params=list(rip=0.2), 
                                norm_fn = "median", 
                                apply_norm = FALSE, 
                                backtransform = TRUE)
norm_data <- normalize_global(omicsData = mypepData, 
                              subset_fn = "rip", 
                              params=list(rip=0.2), 
                              norm_fn = "median", 
                              apply_norm = TRUE, 
                              backtransform = TRUE)
plot(norm_data, 
     title_plot="Normalized Data: Median Centering Using RIP 0.2 Peptides", 
     title_size=12,
     bw_theme = TRUE)

```

This is the same function that would be used post-SPANS if the user chooses to run SPANS on proteomic data.

<br>

### 7c. SPANS

If using proteomics data and unsure how to normalize, the `spans_procedure()` function will generate statistics the user can use to select a method. SPANS ranks different combinations of sub-setting and normalization methods based on a 'score' that captures how much bias a particular normalization procedure introduces into the data. A higher 'score' implies less bias. [@webb2011statistical]

SPANS tests bias for all the aforementioned sub-setting and normalization procedures by default. Default settings are used to determine the best normalization procedure for mypepData.

```{r spans}
# returns a dataframe arranged by descending SPANS score
spans_result <- spans_procedure(mypepData)
```

```{r spans_plot_summarize}
summary(spans_result)
plot(spans_result)
```

```{r spans_normalize}
# a list of the parameters for any normalization procedure with the best SPANS score
best_params <- get_spans_params(spans_result)

# there are a few ties, all using ppp_rip
# we'll select the method that uses median normalization and parameters ppp = 0.1 and rip = 0.1
subset_fn = best_params[[1]]$subset_fn
norm_fn = best_params[[1]]$norm_fn
params = best_params[[1]]$params

# we now pass the extracted subset function, normalization function, and parameters from SPANS to normalize_global()
norm_object <- normalize_global(omicsData = mypepData, 
                                subset_fn = subset_fn, 
                                norm_fn = norm_fn, 
                                params = params,
                                apply_norm = TRUE,
                                backtransform = TRUE)
```

--------

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Feature note:** SPANS is restricted to peptide and protein data and works best when large datasets are available due to data sub-setting (though it does take some time). Errors may generate for certain procedures if the dataset size is insufficient. To fix this issue, try reducing the number of subset functions that are tested.

</div>

-----

## 8. Protein quantification

Protein quantification can be done using the `protein_quant()` function, either with or without accounting for different isoforms of the proteins, also called 'proteoforms'. Regardless of whether the user is accounting for protein isoforms, they must specify a method for rolling peptides up to proteins (one of "rollup", "rrollup", "qrollup", or "zrollup") and a function to use for combining the peptide-level data (either "mean" or "median"). When the user does wish to account for protein isoforms, they have the option for doing so with **Bayesian Proteoform Quantification (BP-Quant)** [@webb2014bayesian]. 


<br>

### 8a. Proteoform detection with BP-Quant [@webb2014bayesian]

Proteoforms (including protein post-translational modification, splice variants, etc.) are important factors to consider when assessing the biological impact of experimental groups. BP-Quant predicts any proteoforms present for each protein group by identifying trends from quantitative (ANOVA) and qualitative (G-test for independence of missing data) tests across experimental group comparisons. These relationships are summarized in the format of a vector of “signatures”, where 0 indicates no statistically significant difference between experimental groups and 1 or -1 respectively represent a statistically significant increased or decreased value between experimental groups. BPQuant uses these signatures in the Bayesian model to select the set of proteoforms with the maximum likelihood for each protein [@webb2014bayesian].

In pmartR, this method is available using the function `bpquant()`, demonstrated below. Note that this function takes advantage of statistical results generated from pmartR using the function `imdanova()`, further covered in the vignette 'Statistical Analysis with the pmartR Package'.

The output of this function produced a list, where each element contains a data.frame defining proteoform identifiers for each peptide mapping to that protein. Where proteoform ID is zero, the peptide does not fit in the dominant trends identified for that protein.

```{r pbpquant}

peptideStats <- imd_anova(norm_object, 
                          test_method = "combined", 
                          pval_thresh = 0.05, 
                          pval_adjust = 'bonferroni')

proteoforms <- bpquant(peptideStats, norm_object)

proteoforms[[49]] ## An example of an output element

```

-----

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Feature note:** Where there is insufficient data for either statistical test, the peptide abundances cannot be converted to a signature. The imdanova_filter will help to determine if this is the case for any dataset!

</div>

--------

### 8b. Rollup methods

The **rollup** method takes either the mean or median of all peptides mapping to a given protein, and sets that value as the relative protein abundance.

In the **rrollup** method, all peptides that map to a single protein are scaled based on a chosen reference peptide, which is the peptide with most observations. Next the average or mean of the scaled peptides is set as the relative protein abundance. [@matzke2013comparative] 

The **qrollup** method starts with all peptides that map to a single protein. Next peptides are chosen according to an abundance cutoff value and the average or mean of the scaled peptides is set as the protein abundance. [@polpitiya2008dante]

In the **zrollup** method, scaling is done similarly to the  z-score formula (except with medians instead of means). The scaling formula is applied to peptides that map to a single protein and then the mean or median of the scaled peptides is set as protein abundance (from DAnTE article). The rollup method is similar to rrollup method, except there is no scaling involved in these methods. Either the mean or median is applied to all peptides that map to a single protein to obtain protein abundance. [@polpitiya2008dante]


<br>

The `protein_quant()` function returns a pmartR data object of class proData.

```{r protein_quant}

myprodata_rrollup<- pmartR::protein_quant(pepData = norm_object, method = "rrollup")
print(myprodata_rrollup)
plot(myprodata_rrollup, bw_theme = TRUE)
rm(myprodata_rrollup)

myprodata_rrollup<- pmartR::protein_quant(pepData = norm_object, method = "rrollup", isoformRes = proteoforms)
print(myprodata_rrollup)
plot(myprodata_rrollup, bw_theme = TRUE)
rm(myprodata_rrollup)


```

<br>

## References
